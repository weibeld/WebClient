mport { openpgp } from '../openpgp';
import { cloneKey } from './utils';
import { serverTime } from '../serverTime';

export function encryptPrivateKey(inputKey, privKeyPassCode) {
    console.log(`[Call] pmcrypto.encryptPrivateKey()
inputKey: ${JSON.stringify(inputKey, null, 2)}
privKeyPassCode: ${privKeyPassCode}`);
    return Promise.resolve(cloneKey(inputKey)).then(async (privKey) => {
        if (Object.prototype.toString.call(privKeyPassCode) !== '[object String]' || privKeyPassCode === '') {
            return Promise.reject(new Error('Missing private key passcode'));
        }

        if (!{}.isPrototypeOf.call(openpgp.key.Key.prototype, privKey)) {
            return Promise.reject(new Error('Not a Key object'));
        }

        if (!privKey.isPrivate()) {
            return Promise.reject(new Error('Not a private key'));
        }

        if (privKey.keyPacket === null || privKey.subKeys === null || privKey.subKeys.length === 0) {
            return Promise.reject(new Error('Missing primary key or subkey'));
        }

        const result = await privKey.encrypt(privKeyPassCode).then(() => privKey.armor());
        console.log(`[Return] pmcrypto.encryptPrivateKey()\n${JSON.stringify(result, null, 2)}`);
        return Promise.resolve(result);
    });
}

export const encryptSessionKey = ({ date = serverTime(), ...rest }) => openpgp.encryptSessionKey({ date, ...rest });
